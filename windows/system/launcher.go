// Code generated by winrt-go-gen. DO NOT EDIT.

//go:build windows

//nolint:all
package system

import (
	"syscall"
	"unsafe"

	"github.com/go-ole/go-ole"
	"github.com/martytsaitw/winrt-go/windows/foundation"
	"github.com/martytsaitw/winrt-go/windows/foundation/collections"
	"github.com/martytsaitw/winrt-go/windows/storage"
)

const GUIDiLauncherStatics3 string = "234261a8-9db3-4683-aa42-dc6f51d33847"
const SignatureiLauncherStatics3 string = "{234261a8-9db3-4683-aa42-dc6f51d33847}"

type iLauncherStatics3 struct {
	ole.IInspectable
}

type iLauncherStatics3Vtbl struct {
	ole.IInspectableVtbl

	LauncherLaunchFolderAsync            uintptr
	LauncherLaunchFolderWithOptionsAsync uintptr
}

func (v *iLauncherStatics3) VTable() *iLauncherStatics3Vtbl {
	return (*iLauncherStatics3Vtbl)(unsafe.Pointer(v.RawVTable))
}

func LauncherLaunchFolderAsync(folder *storage.IStorageFolder) (*foundation.IAsyncOperation, error) {
	inspectable, err := ole.RoGetActivationFactory("Windows.System.Launcher", ole.NewGUID(GUIDiLauncherStatics3))
	if err != nil {
		return nil, err
	}
	v := (*iLauncherStatics3)(unsafe.Pointer(inspectable))

	var out *foundation.IAsyncOperation
	hr, _, _ := syscall.SyscallN(
		v.VTable().LauncherLaunchFolderAsync,
		0,                               // this is a static func, so there's no this
		uintptr(unsafe.Pointer(folder)), // in storage.IStorageFolder
		uintptr(unsafe.Pointer(&out)),   // out foundation.IAsyncOperation
	)

	if hr != 0 {
		return nil, ole.NewError(hr)
	}

	return out, nil
}

func LauncherLaunchFolderWithOptionsAsync(folder *storage.IStorageFolder, options *FolderLauncherOptions) (*foundation.IAsyncOperation, error) {
	inspectable, err := ole.RoGetActivationFactory("Windows.System.Launcher", ole.NewGUID(GUIDiLauncherStatics3))
	if err != nil {
		return nil, err
	}
	v := (*iLauncherStatics3)(unsafe.Pointer(inspectable))

	var out *foundation.IAsyncOperation
	hr, _, _ := syscall.SyscallN(
		v.VTable().LauncherLaunchFolderWithOptionsAsync,
		0,                                // this is a static func, so there's no this
		uintptr(unsafe.Pointer(folder)),  // in storage.IStorageFolder
		uintptr(unsafe.Pointer(options)), // in FolderLauncherOptions
		uintptr(unsafe.Pointer(&out)),    // out foundation.IAsyncOperation
	)

	if hr != 0 {
		return nil, ole.NewError(hr)
	}

	return out, nil
}

const GUIDiLauncherStatics4 string = "b9ec819f-b5a5-41c6-b3b3-dd1b3178bcf2"
const SignatureiLauncherStatics4 string = "{b9ec819f-b5a5-41c6-b3b3-dd1b3178bcf2}"

type iLauncherStatics4 struct {
	ole.IInspectable
}

type iLauncherStatics4Vtbl struct {
	ole.IInspectableVtbl

	LauncherQueryAppUriSupportAsync                      uintptr
	LauncherQueryAppUriSupportWithPackageFamilyNameAsync uintptr
	LauncherFindAppUriHandlersAsync                      uintptr
	LauncherLaunchUriForUserAsync                        uintptr
	LauncherLaunchUriWithOptionsForUserAsync             uintptr
	LauncherLaunchUriWithDataForUserAsync                uintptr
	LauncherLaunchUriForResultsForUserAsync              uintptr
	LauncherLaunchUriForResultsWithDataForUserAsync      uintptr
}

func (v *iLauncherStatics4) VTable() *iLauncherStatics4Vtbl {
	return (*iLauncherStatics4Vtbl)(unsafe.Pointer(v.RawVTable))
}

func LauncherQueryAppUriSupportAsync(uri *foundation.Uri) (*foundation.IAsyncOperation, error) {
	inspectable, err := ole.RoGetActivationFactory("Windows.System.Launcher", ole.NewGUID(GUIDiLauncherStatics4))
	if err != nil {
		return nil, err
	}
	v := (*iLauncherStatics4)(unsafe.Pointer(inspectable))

	var out *foundation.IAsyncOperation
	hr, _, _ := syscall.SyscallN(
		v.VTable().LauncherQueryAppUriSupportAsync,
		0,                             // this is a static func, so there's no this
		uintptr(unsafe.Pointer(uri)),  // in foundation.Uri
		uintptr(unsafe.Pointer(&out)), // out foundation.IAsyncOperation
	)

	if hr != 0 {
		return nil, ole.NewError(hr)
	}

	return out, nil
}

func LauncherQueryAppUriSupportWithPackageFamilyNameAsync(uri *foundation.Uri, packageFamilyName string) (*foundation.IAsyncOperation, error) {
	inspectable, err := ole.RoGetActivationFactory("Windows.System.Launcher", ole.NewGUID(GUIDiLauncherStatics4))
	if err != nil {
		return nil, err
	}
	v := (*iLauncherStatics4)(unsafe.Pointer(inspectable))

	var out *foundation.IAsyncOperation
	packageFamilyNameHStr, err := ole.NewHString(packageFamilyName)
	if err != nil {
		return nil, err
	}
	hr, _, _ := syscall.SyscallN(
		v.VTable().LauncherQueryAppUriSupportWithPackageFamilyNameAsync,
		0,                              // this is a static func, so there's no this
		uintptr(unsafe.Pointer(uri)),   // in foundation.Uri
		uintptr(packageFamilyNameHStr), // in string
		uintptr(unsafe.Pointer(&out)),  // out foundation.IAsyncOperation
	)

	if hr != 0 {
		return nil, ole.NewError(hr)
	}

	return out, nil
}

func LauncherFindAppUriHandlersAsync(uri *foundation.Uri) (*foundation.IAsyncOperation, error) {
	inspectable, err := ole.RoGetActivationFactory("Windows.System.Launcher", ole.NewGUID(GUIDiLauncherStatics4))
	if err != nil {
		return nil, err
	}
	v := (*iLauncherStatics4)(unsafe.Pointer(inspectable))

	var out *foundation.IAsyncOperation
	hr, _, _ := syscall.SyscallN(
		v.VTable().LauncherFindAppUriHandlersAsync,
		0,                             // this is a static func, so there's no this
		uintptr(unsafe.Pointer(uri)),  // in foundation.Uri
		uintptr(unsafe.Pointer(&out)), // out foundation.IAsyncOperation
	)

	if hr != 0 {
		return nil, ole.NewError(hr)
	}

	return out, nil
}

func LauncherLaunchUriForUserAsync(user *User, uri *foundation.Uri) (*foundation.IAsyncOperation, error) {
	inspectable, err := ole.RoGetActivationFactory("Windows.System.Launcher", ole.NewGUID(GUIDiLauncherStatics4))
	if err != nil {
		return nil, err
	}
	v := (*iLauncherStatics4)(unsafe.Pointer(inspectable))

	var out *foundation.IAsyncOperation
	hr, _, _ := syscall.SyscallN(
		v.VTable().LauncherLaunchUriForUserAsync,
		0,                             // this is a static func, so there's no this
		uintptr(unsafe.Pointer(user)), // in User
		uintptr(unsafe.Pointer(uri)),  // in foundation.Uri
		uintptr(unsafe.Pointer(&out)), // out foundation.IAsyncOperation
	)

	if hr != 0 {
		return nil, ole.NewError(hr)
	}

	return out, nil
}

func LauncherLaunchUriWithOptionsForUserAsync(user *User, uri *foundation.Uri, options *LauncherOptions) (*foundation.IAsyncOperation, error) {
	inspectable, err := ole.RoGetActivationFactory("Windows.System.Launcher", ole.NewGUID(GUIDiLauncherStatics4))
	if err != nil {
		return nil, err
	}
	v := (*iLauncherStatics4)(unsafe.Pointer(inspectable))

	var out *foundation.IAsyncOperation
	hr, _, _ := syscall.SyscallN(
		v.VTable().LauncherLaunchUriWithOptionsForUserAsync,
		0,                                // this is a static func, so there's no this
		uintptr(unsafe.Pointer(user)),    // in User
		uintptr(unsafe.Pointer(uri)),     // in foundation.Uri
		uintptr(unsafe.Pointer(options)), // in LauncherOptions
		uintptr(unsafe.Pointer(&out)),    // out foundation.IAsyncOperation
	)

	if hr != 0 {
		return nil, ole.NewError(hr)
	}

	return out, nil
}

func LauncherLaunchUriWithDataForUserAsync(user *User, uri *foundation.Uri, options *LauncherOptions, inputData *collections.ValueSet) (*foundation.IAsyncOperation, error) {
	inspectable, err := ole.RoGetActivationFactory("Windows.System.Launcher", ole.NewGUID(GUIDiLauncherStatics4))
	if err != nil {
		return nil, err
	}
	v := (*iLauncherStatics4)(unsafe.Pointer(inspectable))

	var out *foundation.IAsyncOperation
	hr, _, _ := syscall.SyscallN(
		v.VTable().LauncherLaunchUriWithDataForUserAsync,
		0,                                  // this is a static func, so there's no this
		uintptr(unsafe.Pointer(user)),      // in User
		uintptr(unsafe.Pointer(uri)),       // in foundation.Uri
		uintptr(unsafe.Pointer(options)),   // in LauncherOptions
		uintptr(unsafe.Pointer(inputData)), // in collections.ValueSet
		uintptr(unsafe.Pointer(&out)),      // out foundation.IAsyncOperation
	)

	if hr != 0 {
		return nil, ole.NewError(hr)
	}

	return out, nil
}

func LauncherLaunchUriForResultsForUserAsync(user *User, uri *foundation.Uri, options *LauncherOptions) (*foundation.IAsyncOperation, error) {
	inspectable, err := ole.RoGetActivationFactory("Windows.System.Launcher", ole.NewGUID(GUIDiLauncherStatics4))
	if err != nil {
		return nil, err
	}
	v := (*iLauncherStatics4)(unsafe.Pointer(inspectable))

	var out *foundation.IAsyncOperation
	hr, _, _ := syscall.SyscallN(
		v.VTable().LauncherLaunchUriForResultsForUserAsync,
		0,                                // this is a static func, so there's no this
		uintptr(unsafe.Pointer(user)),    // in User
		uintptr(unsafe.Pointer(uri)),     // in foundation.Uri
		uintptr(unsafe.Pointer(options)), // in LauncherOptions
		uintptr(unsafe.Pointer(&out)),    // out foundation.IAsyncOperation
	)

	if hr != 0 {
		return nil, ole.NewError(hr)
	}

	return out, nil
}

func LauncherLaunchUriForResultsWithDataForUserAsync(user *User, uri *foundation.Uri, options *LauncherOptions, inputData *collections.ValueSet) (*foundation.IAsyncOperation, error) {
	inspectable, err := ole.RoGetActivationFactory("Windows.System.Launcher", ole.NewGUID(GUIDiLauncherStatics4))
	if err != nil {
		return nil, err
	}
	v := (*iLauncherStatics4)(unsafe.Pointer(inspectable))

	var out *foundation.IAsyncOperation
	hr, _, _ := syscall.SyscallN(
		v.VTable().LauncherLaunchUriForResultsWithDataForUserAsync,
		0,                                  // this is a static func, so there's no this
		uintptr(unsafe.Pointer(user)),      // in User
		uintptr(unsafe.Pointer(uri)),       // in foundation.Uri
		uintptr(unsafe.Pointer(options)),   // in LauncherOptions
		uintptr(unsafe.Pointer(inputData)), // in collections.ValueSet
		uintptr(unsafe.Pointer(&out)),      // out foundation.IAsyncOperation
	)

	if hr != 0 {
		return nil, ole.NewError(hr)
	}

	return out, nil
}

const GUIDiLauncherStatics5 string = "5b24ef84-d895-5fea-9153-1ac49aed9ba9"
const SignatureiLauncherStatics5 string = "{5b24ef84-d895-5fea-9153-1ac49aed9ba9}"

type iLauncherStatics5 struct {
	ole.IInspectable
}

type iLauncherStatics5Vtbl struct {
	ole.IInspectableVtbl

	LauncherLaunchFolderPathAsync                   uintptr
	LauncherLaunchFolderPathWithOptionsAsync        uintptr
	LauncherLaunchFolderPathForUserAsync            uintptr
	LauncherLaunchFolderPathWithOptionsForUserAsync uintptr
}

func (v *iLauncherStatics5) VTable() *iLauncherStatics5Vtbl {
	return (*iLauncherStatics5Vtbl)(unsafe.Pointer(v.RawVTable))
}

func LauncherLaunchFolderPathAsync(path string) (*foundation.IAsyncOperation, error) {
	inspectable, err := ole.RoGetActivationFactory("Windows.System.Launcher", ole.NewGUID(GUIDiLauncherStatics5))
	if err != nil {
		return nil, err
	}
	v := (*iLauncherStatics5)(unsafe.Pointer(inspectable))

	var out *foundation.IAsyncOperation
	pathHStr, err := ole.NewHString(path)
	if err != nil {
		return nil, err
	}
	hr, _, _ := syscall.SyscallN(
		v.VTable().LauncherLaunchFolderPathAsync,
		0,                             // this is a static func, so there's no this
		uintptr(pathHStr),             // in string
		uintptr(unsafe.Pointer(&out)), // out foundation.IAsyncOperation
	)

	if hr != 0 {
		return nil, ole.NewError(hr)
	}

	return out, nil
}

func LauncherLaunchFolderPathWithOptionsAsync(path string, options *FolderLauncherOptions) (*foundation.IAsyncOperation, error) {
	inspectable, err := ole.RoGetActivationFactory("Windows.System.Launcher", ole.NewGUID(GUIDiLauncherStatics5))
	if err != nil {
		return nil, err
	}
	v := (*iLauncherStatics5)(unsafe.Pointer(inspectable))

	var out *foundation.IAsyncOperation
	pathHStr, err := ole.NewHString(path)
	if err != nil {
		return nil, err
	}
	hr, _, _ := syscall.SyscallN(
		v.VTable().LauncherLaunchFolderPathWithOptionsAsync,
		0,                                // this is a static func, so there's no this
		uintptr(pathHStr),                // in string
		uintptr(unsafe.Pointer(options)), // in FolderLauncherOptions
		uintptr(unsafe.Pointer(&out)),    // out foundation.IAsyncOperation
	)

	if hr != 0 {
		return nil, ole.NewError(hr)
	}

	return out, nil
}

func LauncherLaunchFolderPathForUserAsync(user *User, path string) (*foundation.IAsyncOperation, error) {
	inspectable, err := ole.RoGetActivationFactory("Windows.System.Launcher", ole.NewGUID(GUIDiLauncherStatics5))
	if err != nil {
		return nil, err
	}
	v := (*iLauncherStatics5)(unsafe.Pointer(inspectable))

	var out *foundation.IAsyncOperation
	pathHStr, err := ole.NewHString(path)
	if err != nil {
		return nil, err
	}
	hr, _, _ := syscall.SyscallN(
		v.VTable().LauncherLaunchFolderPathForUserAsync,
		0,                             // this is a static func, so there's no this
		uintptr(unsafe.Pointer(user)), // in User
		uintptr(pathHStr),             // in string
		uintptr(unsafe.Pointer(&out)), // out foundation.IAsyncOperation
	)

	if hr != 0 {
		return nil, ole.NewError(hr)
	}

	return out, nil
}

func LauncherLaunchFolderPathWithOptionsForUserAsync(user *User, path string, options *FolderLauncherOptions) (*foundation.IAsyncOperation, error) {
	inspectable, err := ole.RoGetActivationFactory("Windows.System.Launcher", ole.NewGUID(GUIDiLauncherStatics5))
	if err != nil {
		return nil, err
	}
	v := (*iLauncherStatics5)(unsafe.Pointer(inspectable))

	var out *foundation.IAsyncOperation
	pathHStr, err := ole.NewHString(path)
	if err != nil {
		return nil, err
	}
	hr, _, _ := syscall.SyscallN(
		v.VTable().LauncherLaunchFolderPathWithOptionsForUserAsync,
		0,                                // this is a static func, so there's no this
		uintptr(unsafe.Pointer(user)),    // in User
		uintptr(pathHStr),                // in string
		uintptr(unsafe.Pointer(options)), // in FolderLauncherOptions
		uintptr(unsafe.Pointer(&out)),    // out foundation.IAsyncOperation
	)

	if hr != 0 {
		return nil, ole.NewError(hr)
	}

	return out, nil
}

const GUIDiLauncherStatics2 string = "59ba2fbb-24cb-4c02-a4c4-8294569d54f1"
const SignatureiLauncherStatics2 string = "{59ba2fbb-24cb-4c02-a4c4-8294569d54f1}"

type iLauncherStatics2 struct {
	ole.IInspectable
}

type iLauncherStatics2Vtbl struct {
	ole.IInspectableVtbl

	LauncherLaunchUriForResultsAsync                    uintptr
	LauncherLaunchUriForResultsWithDataAsync            uintptr
	LauncherLaunchUriWithDataAsync                      uintptr
	LauncherQueryUriSupportAsync                        uintptr
	LauncherQueryUriSupportWithPackageFamilyNameAsync   uintptr
	LauncherQueryFileSupportAsync                       uintptr
	LauncherQueryFileSupportWithPackageFamilyNameAsync  uintptr
	LauncherFindUriSchemeHandlersAsync                  uintptr
	LauncherFindUriSchemeHandlersWithLaunchUriTypeAsync uintptr
	LauncherFindFileHandlersAsync                       uintptr
}

func (v *iLauncherStatics2) VTable() *iLauncherStatics2Vtbl {
	return (*iLauncherStatics2Vtbl)(unsafe.Pointer(v.RawVTable))
}

func LauncherLaunchUriForResultsAsync(uri *foundation.Uri, options *LauncherOptions) (*foundation.IAsyncOperation, error) {
	inspectable, err := ole.RoGetActivationFactory("Windows.System.Launcher", ole.NewGUID(GUIDiLauncherStatics2))
	if err != nil {
		return nil, err
	}
	v := (*iLauncherStatics2)(unsafe.Pointer(inspectable))

	var out *foundation.IAsyncOperation
	hr, _, _ := syscall.SyscallN(
		v.VTable().LauncherLaunchUriForResultsAsync,
		0,                                // this is a static func, so there's no this
		uintptr(unsafe.Pointer(uri)),     // in foundation.Uri
		uintptr(unsafe.Pointer(options)), // in LauncherOptions
		uintptr(unsafe.Pointer(&out)),    // out foundation.IAsyncOperation
	)

	if hr != 0 {
		return nil, ole.NewError(hr)
	}

	return out, nil
}

func LauncherLaunchUriForResultsWithDataAsync(uri *foundation.Uri, options *LauncherOptions, inputData *collections.ValueSet) (*foundation.IAsyncOperation, error) {
	inspectable, err := ole.RoGetActivationFactory("Windows.System.Launcher", ole.NewGUID(GUIDiLauncherStatics2))
	if err != nil {
		return nil, err
	}
	v := (*iLauncherStatics2)(unsafe.Pointer(inspectable))

	var out *foundation.IAsyncOperation
	hr, _, _ := syscall.SyscallN(
		v.VTable().LauncherLaunchUriForResultsWithDataAsync,
		0,                                  // this is a static func, so there's no this
		uintptr(unsafe.Pointer(uri)),       // in foundation.Uri
		uintptr(unsafe.Pointer(options)),   // in LauncherOptions
		uintptr(unsafe.Pointer(inputData)), // in collections.ValueSet
		uintptr(unsafe.Pointer(&out)),      // out foundation.IAsyncOperation
	)

	if hr != 0 {
		return nil, ole.NewError(hr)
	}

	return out, nil
}

func LauncherLaunchUriWithDataAsync(uri *foundation.Uri, options *LauncherOptions, inputData *collections.ValueSet) (*foundation.IAsyncOperation, error) {
	inspectable, err := ole.RoGetActivationFactory("Windows.System.Launcher", ole.NewGUID(GUIDiLauncherStatics2))
	if err != nil {
		return nil, err
	}
	v := (*iLauncherStatics2)(unsafe.Pointer(inspectable))

	var out *foundation.IAsyncOperation
	hr, _, _ := syscall.SyscallN(
		v.VTable().LauncherLaunchUriWithDataAsync,
		0,                                  // this is a static func, so there's no this
		uintptr(unsafe.Pointer(uri)),       // in foundation.Uri
		uintptr(unsafe.Pointer(options)),   // in LauncherOptions
		uintptr(unsafe.Pointer(inputData)), // in collections.ValueSet
		uintptr(unsafe.Pointer(&out)),      // out foundation.IAsyncOperation
	)

	if hr != 0 {
		return nil, ole.NewError(hr)
	}

	return out, nil
}

func LauncherQueryUriSupportAsync(uri *foundation.Uri, launchQuerySupportType LaunchQuerySupportType) (*foundation.IAsyncOperation, error) {
	inspectable, err := ole.RoGetActivationFactory("Windows.System.Launcher", ole.NewGUID(GUIDiLauncherStatics2))
	if err != nil {
		return nil, err
	}
	v := (*iLauncherStatics2)(unsafe.Pointer(inspectable))

	var out *foundation.IAsyncOperation
	hr, _, _ := syscall.SyscallN(
		v.VTable().LauncherQueryUriSupportAsync,
		0,                               // this is a static func, so there's no this
		uintptr(unsafe.Pointer(uri)),    // in foundation.Uri
		uintptr(launchQuerySupportType), // in LaunchQuerySupportType
		uintptr(unsafe.Pointer(&out)),   // out foundation.IAsyncOperation
	)

	if hr != 0 {
		return nil, ole.NewError(hr)
	}

	return out, nil
}

func LauncherQueryUriSupportWithPackageFamilyNameAsync(uri *foundation.Uri, launchQuerySupportType LaunchQuerySupportType, packageFamilyName string) (*foundation.IAsyncOperation, error) {
	inspectable, err := ole.RoGetActivationFactory("Windows.System.Launcher", ole.NewGUID(GUIDiLauncherStatics2))
	if err != nil {
		return nil, err
	}
	v := (*iLauncherStatics2)(unsafe.Pointer(inspectable))

	var out *foundation.IAsyncOperation
	packageFamilyNameHStr, err := ole.NewHString(packageFamilyName)
	if err != nil {
		return nil, err
	}
	hr, _, _ := syscall.SyscallN(
		v.VTable().LauncherQueryUriSupportWithPackageFamilyNameAsync,
		0,                               // this is a static func, so there's no this
		uintptr(unsafe.Pointer(uri)),    // in foundation.Uri
		uintptr(launchQuerySupportType), // in LaunchQuerySupportType
		uintptr(packageFamilyNameHStr),  // in string
		uintptr(unsafe.Pointer(&out)),   // out foundation.IAsyncOperation
	)

	if hr != 0 {
		return nil, ole.NewError(hr)
	}

	return out, nil
}

func LauncherQueryFileSupportAsync(file *storage.StorageFile) (*foundation.IAsyncOperation, error) {
	inspectable, err := ole.RoGetActivationFactory("Windows.System.Launcher", ole.NewGUID(GUIDiLauncherStatics2))
	if err != nil {
		return nil, err
	}
	v := (*iLauncherStatics2)(unsafe.Pointer(inspectable))

	var out *foundation.IAsyncOperation
	hr, _, _ := syscall.SyscallN(
		v.VTable().LauncherQueryFileSupportAsync,
		0,                             // this is a static func, so there's no this
		uintptr(unsafe.Pointer(file)), // in storage.StorageFile
		uintptr(unsafe.Pointer(&out)), // out foundation.IAsyncOperation
	)

	if hr != 0 {
		return nil, ole.NewError(hr)
	}

	return out, nil
}

func LauncherQueryFileSupportWithPackageFamilyNameAsync(file *storage.StorageFile, packageFamilyName string) (*foundation.IAsyncOperation, error) {
	inspectable, err := ole.RoGetActivationFactory("Windows.System.Launcher", ole.NewGUID(GUIDiLauncherStatics2))
	if err != nil {
		return nil, err
	}
	v := (*iLauncherStatics2)(unsafe.Pointer(inspectable))

	var out *foundation.IAsyncOperation
	packageFamilyNameHStr, err := ole.NewHString(packageFamilyName)
	if err != nil {
		return nil, err
	}
	hr, _, _ := syscall.SyscallN(
		v.VTable().LauncherQueryFileSupportWithPackageFamilyNameAsync,
		0,                              // this is a static func, so there's no this
		uintptr(unsafe.Pointer(file)),  // in storage.StorageFile
		uintptr(packageFamilyNameHStr), // in string
		uintptr(unsafe.Pointer(&out)),  // out foundation.IAsyncOperation
	)

	if hr != 0 {
		return nil, ole.NewError(hr)
	}

	return out, nil
}

func LauncherFindUriSchemeHandlersAsync(scheme string) (*foundation.IAsyncOperation, error) {
	inspectable, err := ole.RoGetActivationFactory("Windows.System.Launcher", ole.NewGUID(GUIDiLauncherStatics2))
	if err != nil {
		return nil, err
	}
	v := (*iLauncherStatics2)(unsafe.Pointer(inspectable))

	var out *foundation.IAsyncOperation
	schemeHStr, err := ole.NewHString(scheme)
	if err != nil {
		return nil, err
	}
	hr, _, _ := syscall.SyscallN(
		v.VTable().LauncherFindUriSchemeHandlersAsync,
		0,                             // this is a static func, so there's no this
		uintptr(schemeHStr),           // in string
		uintptr(unsafe.Pointer(&out)), // out foundation.IAsyncOperation
	)

	if hr != 0 {
		return nil, ole.NewError(hr)
	}

	return out, nil
}

func LauncherFindUriSchemeHandlersWithLaunchUriTypeAsync(scheme string, launchQuerySupportType LaunchQuerySupportType) (*foundation.IAsyncOperation, error) {
	inspectable, err := ole.RoGetActivationFactory("Windows.System.Launcher", ole.NewGUID(GUIDiLauncherStatics2))
	if err != nil {
		return nil, err
	}
	v := (*iLauncherStatics2)(unsafe.Pointer(inspectable))

	var out *foundation.IAsyncOperation
	schemeHStr, err := ole.NewHString(scheme)
	if err != nil {
		return nil, err
	}
	hr, _, _ := syscall.SyscallN(
		v.VTable().LauncherFindUriSchemeHandlersWithLaunchUriTypeAsync,
		0,                               // this is a static func, so there's no this
		uintptr(schemeHStr),             // in string
		uintptr(launchQuerySupportType), // in LaunchQuerySupportType
		uintptr(unsafe.Pointer(&out)),   // out foundation.IAsyncOperation
	)

	if hr != 0 {
		return nil, ole.NewError(hr)
	}

	return out, nil
}

func LauncherFindFileHandlersAsync(extension string) (*foundation.IAsyncOperation, error) {
	inspectable, err := ole.RoGetActivationFactory("Windows.System.Launcher", ole.NewGUID(GUIDiLauncherStatics2))
	if err != nil {
		return nil, err
	}
	v := (*iLauncherStatics2)(unsafe.Pointer(inspectable))

	var out *foundation.IAsyncOperation
	extensionHStr, err := ole.NewHString(extension)
	if err != nil {
		return nil, err
	}
	hr, _, _ := syscall.SyscallN(
		v.VTable().LauncherFindFileHandlersAsync,
		0,                             // this is a static func, so there's no this
		uintptr(extensionHStr),        // in string
		uintptr(unsafe.Pointer(&out)), // out foundation.IAsyncOperation
	)

	if hr != 0 {
		return nil, ole.NewError(hr)
	}

	return out, nil
}

const GUIDiLauncherStatics string = "277151c3-9e3e-42f6-91a4-5dfdeb232451"
const SignatureiLauncherStatics string = "{277151c3-9e3e-42f6-91a4-5dfdeb232451}"

type iLauncherStatics struct {
	ole.IInspectable
}

type iLauncherStaticsVtbl struct {
	ole.IInspectableVtbl

	LauncherLaunchFileAsync            uintptr
	LauncherLaunchFileWithOptionsAsync uintptr
	LauncherLaunchUriAsync             uintptr
	LauncherLaunchUriWithOptionsAsync  uintptr
}

func (v *iLauncherStatics) VTable() *iLauncherStaticsVtbl {
	return (*iLauncherStaticsVtbl)(unsafe.Pointer(v.RawVTable))
}

func LauncherLaunchFileAsync(file *storage.IStorageFile) (*foundation.IAsyncOperation, error) {
	inspectable, err := ole.RoGetActivationFactory("Windows.System.Launcher", ole.NewGUID(GUIDiLauncherStatics))
	if err != nil {
		return nil, err
	}
	v := (*iLauncherStatics)(unsafe.Pointer(inspectable))

	var out *foundation.IAsyncOperation
	hr, _, _ := syscall.SyscallN(
		v.VTable().LauncherLaunchFileAsync,
		0,                             // this is a static func, so there's no this
		uintptr(unsafe.Pointer(file)), // in storage.IStorageFile
		uintptr(unsafe.Pointer(&out)), // out foundation.IAsyncOperation
	)

	if hr != 0 {
		return nil, ole.NewError(hr)
	}

	return out, nil
}

func LauncherLaunchFileWithOptionsAsync(file *storage.IStorageFile, options *LauncherOptions) (*foundation.IAsyncOperation, error) {
	inspectable, err := ole.RoGetActivationFactory("Windows.System.Launcher", ole.NewGUID(GUIDiLauncherStatics))
	if err != nil {
		return nil, err
	}
	v := (*iLauncherStatics)(unsafe.Pointer(inspectable))

	var out *foundation.IAsyncOperation
	hr, _, _ := syscall.SyscallN(
		v.VTable().LauncherLaunchFileWithOptionsAsync,
		0,                                // this is a static func, so there's no this
		uintptr(unsafe.Pointer(file)),    // in storage.IStorageFile
		uintptr(unsafe.Pointer(options)), // in LauncherOptions
		uintptr(unsafe.Pointer(&out)),    // out foundation.IAsyncOperation
	)

	if hr != 0 {
		return nil, ole.NewError(hr)
	}

	return out, nil
}

func LauncherLaunchUriAsync(uri *foundation.Uri) (*foundation.IAsyncOperation, error) {
	inspectable, err := ole.RoGetActivationFactory("Windows.System.Launcher", ole.NewGUID(GUIDiLauncherStatics))
	if err != nil {
		return nil, err
	}
	v := (*iLauncherStatics)(unsafe.Pointer(inspectable))

	var out *foundation.IAsyncOperation
	hr, _, _ := syscall.SyscallN(
		v.VTable().LauncherLaunchUriAsync,
		0,                             // this is a static func, so there's no this
		uintptr(unsafe.Pointer(uri)),  // in foundation.Uri
		uintptr(unsafe.Pointer(&out)), // out foundation.IAsyncOperation
	)

	if hr != 0 {
		return nil, ole.NewError(hr)
	}

	return out, nil
}

func LauncherLaunchUriWithOptionsAsync(uri *foundation.Uri, options *LauncherOptions) (*foundation.IAsyncOperation, error) {
	inspectable, err := ole.RoGetActivationFactory("Windows.System.Launcher", ole.NewGUID(GUIDiLauncherStatics))
	if err != nil {
		return nil, err
	}
	v := (*iLauncherStatics)(unsafe.Pointer(inspectable))

	var out *foundation.IAsyncOperation
	hr, _, _ := syscall.SyscallN(
		v.VTable().LauncherLaunchUriWithOptionsAsync,
		0,                                // this is a static func, so there's no this
		uintptr(unsafe.Pointer(uri)),     // in foundation.Uri
		uintptr(unsafe.Pointer(options)), // in LauncherOptions
		uintptr(unsafe.Pointer(&out)),    // out foundation.IAsyncOperation
	)

	if hr != 0 {
		return nil, ole.NewError(hr)
	}

	return out, nil
}
